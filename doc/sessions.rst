.. _sessions:

********************
Sessions
********************

This document provides a quick intro to using sessions, first just with the
default in-memory store, and then moving on to using :ref:`monger`, which means
we are finally coming full circle!



A New Page
==============

Let's summarize the process of getting a new route up and running. This
integrates stuff we talked about in several prior documents: Ring handlers,
compojure routes, and the Enlive library. There are three required steps we need
to take, plus one optional-but-very-sensible one. 

#. new template fragment for enlive (blah.tpl.html)
#. changes to ``volta.handlers``
      new defsnippet
      new page function
#. change to ``volta.routes``
      add route for desired new page
#. change to ``home.tpl.html``, just for convenience (not strictly necessary!)

Now when you run ``lein ring server`` you should see the new route, and you
should be able to get to that page.


Template fragment
------------------

quick discussion of template fragment contents

Discuss form
Discuss ``div#csrf``... remember that we added ring-defaults!
CSRF protection is considered a basic level of protection, not an advanced
level!
Template is just a placeholder; the actual token will have to be generated.

Handlers
------------

First time we'll actually use the request as part of our handler functions. 

Also note that we'll need to require ``ring.util.anti-forgery``.


The Body Function
.....................

aka the ``(defsnippet)``.

The page function sends the request along
The snippet alters ``:span#visitCount`` to show the current visit count
The snippet builds the ``<ul>`` with all items
Alter the ``div#csrf`` using ``ring-anti-forgery``
  
The snippet is *passive*; it reports on the current status of the request. We
don't alter the session in any way herre. 


The Page Function
......................

Here we read and modify the session.
Not trying to play code golf here: instead going 4 steps in a ``(let)``. 
Could be made terser but I do not think that would be clearer. 
Important thing to remember is how functional everything is.
Immutable references... no atoms!
So we're always creating *new* references

The last statement in the let generates the response-body via the body function,
passing along the *modified* request that has the *modified* session.

Finally, we *explicitly* return the response map. 

Important Side Note: the ``(base-page)`` function that we've been using is
generated by ``(deftemplate)``, which means it only returns a *sequence of
strings*. But a Ring response is a map, not a sequence of strings. Yet all of
our prior examples just returned the results of ``(base-page)`` and they worked
just fine. What's up?

It turns out that Compojure has been providing you with invisible help all
along. If you return a plain string (which all of our previous examples have
done so far), Compojure handles the rest of the details for you, attaching your
string as the ``:body`` of a complete response map. 

That's worked fine until now (although perhaps it has misled us a bit about the real
nature of what's happening). But now that we want to specify a ``:session`` key
as part of the response, we can't get away with that implicit magic any more.
Instead, we must explicitly build our response map, which we do here. We
manually attach the *modified* session object to our final response map. 

Could we just skip that step? Absolutely not. Remember that as we laboriously
demonstrated in a previous tutorial, each layer of middleware expects to get a shot at
both the request map **and** the response map.  That's an explicit part of the
social contract that lets middleware work. And *session* middleware absolutely
needs to do stuff during both phases: it must pull out the old session from the
persistent data store for requests, and it must store the new session in the
persistent data store for responses. So you *must* return your session map under
the ``:session`` key in your response, or the whole system breaks down.


Routes
----------

Finally, we wire this route up. Note that it's attached to GET only. What if a
user wants to add an item? 


Handling POSTS
=================

This time we'll go in reverse order. 

Routes
---------

New POST route for same URI. Cool beans.
Refers to new handler. 

Handler
----------

The ``add-todo-item`` function. 
See notes.
Mention :params vs :form-params, keywords vs strings
Again, feels verbose, but not trying to code gold. 
Look ma, no mutability!

Redirect
...........

A very important helper. 
After we're done generating new references, redirect with the modified session.
Again, the modified session must be *explicitly* added.

This is a fairly clean pattern -- certainly cleaner than handling GET and POST
as explicit ``if/else`` statements in a Django function. Clojure version is
(IMHO) cleaner:

GET function for displaying; GET route goes to this
POST function handles and then redirects to GET; POST route goes to this


Summary
----------

Now users can POST new stuff and it is retained by our persistent store. 
But our persistent store isn't very persistent is it? It's just a
``:memory-store``.
Next stop: sessions in the database



Sessions In Mongo
======================

Mongo includes a built-in persistent store that meets the Ring API for sessions. 
But first we'll need a connection, and that will take some wiring. 

turn on the db
-----------------

Run ``mongod`` in its own terminal. Duh!


volta.datastore
-----------------

Create a new namespace called ``volta.datastore``
Do all of the connection stuff here
def db (mongo/connect)
def coll "web_sessions"
def session-store (blahblah)


Then back to ``volta.routes``

volta.routes
----------------

As part of the call to defaults/wrap-defaults, add our sessionstore
Review the ``ring.defaults`` docs
Review the ``monger`` docs
Include our custom sessionstore.


summary
-------------

Re-run the sessions page, all should work as before, EXCEPT
If you restart the server, that should not kill old sessions!
Now the sessions should persist

Confirm that Mongo is storing sessions:
   -- In a new terminal, start a REPL
   -- load the Monger packages
   -- look for the new web_sessions collection
   -- check the contents
   -- deleting old sessions should kill web browser sessions




   
